import{_ as n,o as i,c as a,e}from"./app-520BETNP.js";const l={},s=e(`<h2 id="_001-mysql中索引分类" tabindex="-1"><a class="header-anchor" href="#_001-mysql中索引分类" aria-hidden="true">#</a> 001 MySQL中索引分类</h2><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/6971ade0-00a3-11ef-97eb-70cf4959429b.jpg" alt="17137884386671713788437767.png"></p><h2 id="_002-innodb索引与myisam索引实现的区别" tabindex="-1"><a class="header-anchor" href="#_002-innodb索引与myisam索引实现的区别" aria-hidden="true">#</a> 002 InnoDB索引与MyISAM索引实现的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/fae0e103-0072-11ef-8944-70cf4959429b.jpg" alt="img"></p><ul><li><p>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。</p></li><li><p>在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引 。</p></li><li><p>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。</p></li><li><p>MyISAM的表在磁盘上存储在以下文件中： <em>.sdi（描述表结构）、</em>.MYD（数据），*.MYI（索引）</p></li><li><p>InnoDB的表在磁盘上存储在以下文件中： .ibd（表结构、索引和数据都存在一起）</p></li><li><p>InnoDB的非聚簇索引data域存储相应记录主键的值 ，而MyISAM索引记录的是地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p></li><li><p>MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p></li><li><p>InnoDB要求表必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p></li></ul><h2 id="_003-一个表中如果没有创建索引-那么还会创建b-树吗" tabindex="-1"><a class="header-anchor" href="#_003-一个表中如果没有创建索引-那么还会创建b-树吗" aria-hidden="true">#</a> 003 一个表中如果没有创建索引，那么还会创建B+树吗？</h2><p>会</p><ul><li>如果有主键会创建聚簇索引</li><li>如果没有主键会生成rowid作为隐式主键</li></ul><h2 id="_004-说一下b-树索引实现原理-数据结构" tabindex="-1"><a class="header-anchor" href="#_004-说一下b-树索引实现原理-数据结构" aria-hidden="true">#</a> 004 说一下B+树索引实现原理（数据结构）</h2><p>假设有一个表index_demo，表中有2个INT类型的列，1个CHAR(1)类型的列，c1列为主键：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo<span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>index_demo表的简化的行格式示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/2fb2635b-0091-11ef-b0c0-70cf4959429b.jpg" alt="img"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li>record_type：表示记录的类型， 0是普通记录、 2是最小记录、 3 是最大记录、1是B+树非叶子节点记录。</li><li>next_record：表示下一条记录的相对位置，我们用箭头来表明下一条记录。</li><li>各个列的值：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li>其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/3bdeeede-0091-11ef-ac59-70cf4959429b.jpg" alt="img"></p><p>把一些记录放到页里的示意图就是（这里一页就是一个磁盘块，代表一次IO）：</p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/3d3a27ae-0091-11ef-aabd-70cf4959429b.jpg" alt="img"></p><p>MySQL InnoDB的默认的页大小是16KB，因此数据存储在磁盘中，可能会占用多个数据页。如果各个页中的记录没有规律，我们就不得不依次遍历所有的数据页。如果我们想快速的定位到需要查找的记录在哪些数据页中，我们可以这样做 ：</p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</li><li>给所有的页建立目录项</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/2c06b2fd-0091-11ef-b336-70cf4959429b.jpg" alt="img"></p><p>以页28为例，它对应目录项2 ，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值 5。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为 12 ≤ 20 &lt; 209 ），对应页9。</li><li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引 。</p><p><strong>InnoDB中的索引方案</strong></p><p>我们新分配一个编号为30的页来专门存储目录项记录，页10、28、9、20专门存储用户记录：</p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/c4b7f0c5-009f-11ef-b017-70cf4959429b.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/ea6d1efd-009f-11ef-8d14-70cf4959429b.jpg" alt="img"></p><p>目录项记录和普通的用户记录的不同点：</p><ul><li>目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，包含很多列，另外还有InnoDB自己添加的隐藏列。</li></ul><p>现在查找主键值为 20 的记录，具体查找过程分两步：</p><ol><li>先到页30中通过二分法快速定位到对应目录项，因为 12 ≤ 20 &lt; 209 ，就是页9。</li><li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p><strong>更复杂的情况如下：</strong></p><p>我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。<strong>这个数据结构，它的名称是 B+树 。</strong></p><h2 id="_005-聚簇索引与非聚簇索引b-树实现有什么区别" tabindex="-1"><a class="header-anchor" href="#_005-聚簇索引与非聚簇索引b-树实现有什么区别" aria-hidden="true">#</a> 005 聚簇索引与非聚簇索引b+树实现有什么区别？</h2><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 聚簇索引</li></ul><p><strong>特点：</strong></p><ul><li>索引和数据保存在同一个B+树中</li><li>页内的记录是按照主键的大小顺序排成一个单向链表 。</li><li>页和页之间也是根据页中记录的主键的大小顺序排成一个双向链表 。</li><li>非叶子节点存储的是记录的主键+页号。</li><li>叶子节点存储的是完整的用户记录。</li></ul><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快。</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库可以从更少的数据块中提取数据，节省了大量的IO操作 。</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li></ul><p><strong>限制：</strong></p><ul class="contains-task-list"><li><p>只有InnoDB引擎支持聚簇索引，MyISAM不支持聚簇索引。</p></li><li><p>由于数据的物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。</p></li><li><p>如果没有为表定义主键，InnoDB会选择非空的唯一索引列代替。如果没有这样的列，InnoDB会隐式的定义一个主键作为聚簇索引。</p></li><li><p>为了充分利用聚簇索引的聚簇特性，InnoDB中表的主键应选择有序的id，不建议使用无序的id，比如UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 非聚簇索引</p></li></ul><p><strong>（二级索引、辅助索引）</strong></p><p>聚簇索引，只能在搜索条件是主键值时才发挥作用，因为B+树中的数据都是按照主键进行排序的，如果我们想以别的列作为搜索条件，那么需要创建非聚簇索引。</p><p><strong>例如，</strong> 以c2列作为搜索条件，那么需要使用c2列创建一棵B+树，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/8f564ec5-00a0-11ef-9522-70cf4959429b.jpg" alt="img"></p><p><strong>这个B+树与聚簇索引有几处不同：</strong></p><ul><li>页内的记录是按照从c2列的大小顺序排成一个单向链表 。</li><li>页和页之间也是根据页中记录的c2列的大小顺序排成一个双向链表 。</li><li>非叶子节点存储的是记录的c2列+页号。</li><li>叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。</li></ul><p><strong>一张表可以有多个非聚簇索引：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/8f54a24b-00a0-11ef-a0b6-70cf4959429b.jpg" alt="img"></p><h2 id="_006-说一下b-树中非聚簇索引的查找-匹配-逻辑" tabindex="-1"><a class="header-anchor" href="#_006-说一下b-树中非聚簇索引的查找-匹配-逻辑" aria-hidden="true">#</a> 006 说一下B+树中非聚簇索引的查找（匹配）逻辑</h2><p>**例如：**根据c2列的值查找c2=4的记录，查找过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JaikenWong/Drawing-Bed@main/images/2024-04-22/3ff1d77a-00a2-11ef-bdd1-70cf4959429b.jpg" alt="img"></p><ol><li>根据根页面44定位到页42（因为2 ≤ 4 &lt; 9）</li><li>由于c2列没有唯一性约束，所以c2=4的记录可能分布在多个数据页中，又因为 2 ≤ 4 ≤ 4，所以确定实际存储用户记录的页在页34和页35中。</li><li>在页34和35中定位到具体的记录。</li><li>但是这个B+树的叶子节点只存储了c2和c1（主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录（回表）。</li></ol><h2 id="_007-什么时候不需要创建索引" tabindex="-1"><a class="header-anchor" href="#_007-什么时候不需要创建索引" aria-hidden="true">#</a> 007 什么时候不需要创建索引？</h2><ul><li>字段中存在大量重复数据，不需要创建索引；</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引；</li></ul>`,59),p=[s];function t(c,o){return i(),a("div",null,p)}const r=n(l,[["render",t],["__file","MySQLsuoyin1-7.html.vue"]]);export{r as default};
